# 선형 자료 구조


## ch18.1 도입

- 가장 기초적인 자료 구조 : 배열

  - 배열의 비효율 적이거나 할 수 없는 작업들을 개선한 자료 구조 
  -> 동적 배열, 링크드 리스트
______________

## ch18.2 동적 배열

- 배열의 단점 : 배열의 크기 지정 필요, 그 이상의 자료를 집어 넣을 수 없다.

- 동적 배열 : 자료의 개수가 변함에 따라 크기가 변경되는 별도의 자료 구조.

  - 언어 차원에서 제공 되는 기능이 아니라 배열을 이용해 만들어 낸 별도의 자료 구조.(대개 언어의 표준 라이브러리에 포함)
  - 내부적으로 배열을 이용하기 때문에

- 동적 배열 특징은 아래와 같다.

  - 배열과 같은

  1. 원소들은 메모리의 연속된 위치에 저장 됩니다.
  2. 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.
  
  - 배열과 다른

  1. 배열의 크기를 변경하는 resize() 연산이 가능합니다. 이 동작을 수행하는 데 배열의 크기 N에 비례하는 시간이 걸립니다.
주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append() 연산을 지원합니다. 이 동작을 수행 하는 데는 상수 시간이 걸립니다.
이와 같은 연산들을 구현하기 위해 동적 배열은 동적으로 할당 받은 배열을 사용

  2. 동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당 받은 뒤 기존 원소들을 복사하고,
  새 배열을 동적으로 할당 받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 합니다.
  
 - 따라서 동적 배열 클래스는 현재 배열을 가리키는 포인터를 다음과 같이 저장
 
 ***
``` c++
 int size; //배열의 크기 
 ElementType* array; //실제 배열을 가리키는 포인터 
```
 ***
 
``` c++
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>    // malloc, free 함수가 선언된 헤더 파일

int main()
{
    int size;

    scanf("%d", &size);

    int *numPtr = malloc(sizeof(int) * size);    // (int 크기 * 입력받은 크기)만큼 동적 메모리 할당

    for (int i = 0; i < size; i++)    // 입력받은 크기만큼 반복
    {
        numPtr[i] = i;                // 인덱스로 접근하여 값 할당
    }

    for (int i = 0; i < size; i++)    // 입력받은 크기만큼 반복
    {
        printf("%d\n", numPtr[i]);    // 인덱스로 접근하여 값 출력
    }

    free(numPtr);    // 동적으로 할당한 메모리 해제

    return 0;
}
```
 ***
 
![](images/18.1.PNG)

 - 새 배열을 할당 받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸리므로, resize() 연산을 O(N)에 
 구현한다는 요구 조건을 만족
  ***
 ``` c++
 // 배열 용량이 꽉 찼으면 재할당 받는다.
 if(size == capacity){
  //용량을 M만큼 늘린 새 배열을 할당 받는다.
  int newCapacity = capacity + M;
  int* newCapacity = new int[newCapacity];
  //기존의 자료를 복사한다.
  for(int i =0 ; i<size; ++i)
    newArray[i] = array[i];
  //기존 배열을 삭제하고, 새 배열로 바꿔치기한다.
  if(array) delete [] array;
  array = newArray;
  capacity = newCapacity;
 }
 // 배열의 끝에 원소를 삽입한다.
 array[size++] = newValue;
 
 ```
 ***
 
 - append() 함수를 어떻게 상수로 구현?
 
  - 아래 함수는 O(1)로 구현 가능. 
 
 ***
 
  ``` c++
 //append(newValue)의 일부
 array[size++] = newValue;
  ```
 ***
 
  - But Append() 연산 중, 동적 배열이 꽉 차게 되면 resize() 연산을 하게 되어 그 때마다 O(N)의 시간을 소비하게 된다.
  - 어떻게 상수의 시간을 맞출까?
    - 연산을 아주 많이 여러번 반복 하여 수행 시간의 평균을 내는 것.
    
   https://noahlogs.tistory.com/29
 
 __________
 
 ## 18.3 연결 리스트
 
  - 배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 임의의 위치에서 원소를 삭제하는 것은 시간이 오래 걸리는 작업.
    - 해당 위치 뒤에 있는 원소들을 하나씩 뒤칸 혹은 앞칸으로 모두 옮겨야 하기 때문에
    
  - 이와 같은 문제를 해결하기 위해 고안된 자료 구조가 연결 리스트
    - 특정 위치에서의 삽입과 삭제를 상수 시간에 할 수 있게 해줌.
    - 배열은 메모리의 연속된 위치에 각 원소들이 저장되어 있다면, 연결 리스트는 원소들이 메모리 여기 저기 흩어져 있고,
    각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있는 방식으로 구현
    
   
    
   ![배열과 연결 리스트의 차이](images/18.3.PNG)
    
    ***
    
  ``` c++
    struct ListNode {
      int element; //담고 있는 원소
      ListNode *prev, *next; //
      }
  ```
    
    ***
    
   #### 연결 리스트 다루기
  
    - 연결 리스트는 배열과 달리 메모리 여기저기에 노드들이 흩어져 있기 때문에 i 번째 노드를 찾아 내려면 리스트의
    머리에서 부터 시작해 하나씩 포인터를 따라가며 다음 노드를 찾아야한다.
    i 번째 노드를 찾는 데 드는 시간은 리스트의 길이에 선형 비례함.
    
  - 반면 순서를 유지 하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 아주 간단하다.
    - 노드들의 순서가 포인터에 의해 정의 되기 때문에, 다른 노드들은 그대로 두고, 삽입/삭제할 노드와 이전/이후 노드의 포인터만 바꾸면 된다.
    - 그림 18.4 는 노드에서 삭제할 때 추가할 때를 보여준다.
  
   ![](images/18.4.PNG)
   
   #### 표준 라이브러리의 연결 리스트 구현
   
    - C++ : STL의 List
    - JAVA와 C# : LinkedList
    
   #### 연결 리스트 응용 연산들
   
    다음 연산들은 연결 리스트를 가지고 할 수 있는 트릭이지만, 사용 범위가 매우 제한적이고 라이브러리에서 잘 지원하지 않음,
    존재한다고만 알고 있으면 됨.
   
    - 잘라 붙이기 연산
    
      - 원소의 삭제와 삽입을 상수 시간에 할 수 있었던 것을 응용하면 다른 리스트를 통째로 삽입하는 것 또한 상수 시간에 할 수 있다.
      - 그림 18.5 : lg의 일부를 리스트 lotte에 끼워 넣는 연산.
      - 이와 같은 연산을 splicing
      - 잘라 붙이기 연산을 구현하면 상수 시간에 하나로 합치거나 할 수 있어서 유용하지만, 잘라 붙이기를 연산을 구현하면
      연결 리스트의 크기를 O(1) 에 알기가 불가능 해짐.
      - 연결 리스트에서 크기를 알수 있는 방법이 없어서 원소의 개수를 리스트 객체에서 유지하면서 새 원소를 삽입하거나 삭제 할 때마다
      갱신해 줘야 하는데, 잘라 붙이기 연산을 할 때는 몇개의 원소가 추가 되는지 알 방법이 없음.
      - 이와 같은 특성 때문에 잘라 붙이기 연산을 지원하는 연결 리스트 구현은 많지 않음.
      - 자바나 C#에서 사용 하는 LinkedList의 구현은 잘라 붙이기 연산을 포기한 대신, 리스트의 크기를 구하는 연산을 상수 시간에 지원
      - C ++ STL의 List는 splice() 멤버 함수를 통해 잘라 붙이기 연산을 지원하지만, 리스트의 크기를 구하려면
      선형 시간의 반복문을 수행 해야만 함.
      
    
   ![](images/18.5.PNG)
   
   --------
   
    - 삭제했던 원소 돌려 놓기
    
      - 양 방향 연결 리스트의 장점 : 한 번 삭제 했던 원소를 제자리에 쉽게 돌려 놓음.
      - 노드를 삭제하는 DeleteNode() 함수를 보면 우리는 이전/이후의 포인터만 바꾸고 node에 있는 정보는 삭제 하지 않음.
      - 그렇기에 node의 포인터들은 원래 자기가 들어가 있던 위치를 알고 있고, 노드의 위치만 알고 있어서 쉽게 자기 위치로 다시 삽입 가능.
      - 물론 이 방법은 이전 노드나 이후 노드 또한 삭제된 상태에서 수행 하면 리스트를 망가 뜨리기 때문에,
      항상 삭제한 순서의 반대로 복구가 이루어 질때 만 가능
      
  ```c++
    
    //node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다.
    void deleteNode(ListNode* node){
       node->prev->next = node->next;
       node->next->prev = node->prev;
    }
    
    //node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입한다.
    void recoverNode(ListNode* node){
       node->prev->next = node;
       node->next->prev = node;
  ```      
       - 이 연산은 보통 프로그램에서 되돌리기(Undo) 연산을 지원하는 데 유용하게 쓸 수 있음.
       - 되돌리기가 가장 잘 사용 되는 곳은 물론 사용자 인터 페이스
       
       - 11장 조합 탐색에서 사용됨.
        - 조합 탐색에서는 답의 한 조각을 만들고, 현재의 상태를 갱신한 뒤 나머지를 재귀 호출로 해결.
        - 재귀 호출이 끝난 후 문제의 상태는 다시 복구되어야 하는 데 되돌리기 연산을 통해 문제의 상태를 되돌리기 작업을
        효율적으로 할 수 있음
        - 이와 같은 장접을 활용한 기법 : 커누스가 이름 붙인 "춤추는 링크들" 이란 기법이 있음.
       
       
   ## 18.4 동적배열과 연결 리스트의 비교
    
    - 동적 배열과 연결 리스트의 가장 큰 차이점
      - 삽입과 삭제 그리고 임의의 원소에 접근하는 데 드는 시간
        - 배열의 끝에서만 하면 될 경우에는 동적 배열이 거의 항상 더 좋은 선택
          - 임의의 원소에 빠르게 접근할 수 있을 뿐더러, 원소들이 메모리에 연속해 배치되어 있다는 점이 CPU 캐시의 효율도 더 높여 주기 때문.
          - 만약 모든 원소들을 순회하며 삽입과 삭제를 한다면 연결 리스트가 좋은 선택
       
      - 두 자료 구조가 필요로 하는 수행 시간
      
   ![](images/3.PNG)
       
   ## 18.5 조세푸스 문제(문제 ID : JOSEPHUS, 난이도 : 하 )
   
   
   - 예제 입력
   
   2
   6 3
   40 3
  
   - 예제 출력
   
   3 5
   11 26
   
   N = 6, K = 3

예제 입출력 설명

병사들은 1~6번까지, 원 형태로 앉아 있습니다. 이제 1번부터 2명이 남을 때까지 차례대로 죽여 나갈 건데, 아래 표에서 죽인다면
, X를 표시해보도록 하지요. 또한, O는 죽어야 하는 놈을 가리키는 인덱스라고 하겠습니다.


1명 쨰,

| 1 | 2 | 3 | 4 | 5 | 6 |

| X | 2 | 3 | 4 | 5 | 6 |

| O | 2 | 3 | 4 | 5 | 6 |


2명 째,

| 1 | 2  | 3  | 4 | 5 | 6 |

| X | 2  | 3  | X | 5 | 6 |

| X |->|->| O | 5 | 6 |

3명 째,

| 1 | 2 | 3 | 4 | 5  | 6  |

| X | X | 3 | X | 5  | 6  |

| X | O | 3 | X |->|->|

4명 째,

| 1 | 2 | 3  | 4 | 5  | 6 |

| X | X | 3  | X | 5  | X |

| X | X |->| X |->| O |

   
   ## 18.6 풀이 : 조세푸스 문제
   
   - 연결 리스트로 풀 수 있는 전형적인 문제
   
    - 원형으로 연결된 연결 리스트 위에서 이번에 죽을 사람을 포인터 kill을 유지하면서, 이 포인터가 가리키는 사람을
    죽이고 포인터를 K-1번 앞으로 옮기는 방식으로 구현
    - 한사람 죽을 때 마다 포인터를 K-1번 옮기기 때문에, 전체 시간 복잡도는 O(NK)
    - 이 문제는 N,K가 모두 1000 이하의 값이기 때문에 충분히 시간안에 끝낼수 있다.
    - 한가지 문제되는 점은 표준 라이브러리에서 원형으로 연결된 연결 리스트를 제공하지 않는다.
      - 하지만 포인터가 리스트의 끝에 도달하면 처음으로 옮겨 주는 연산을 통해 원형 리스트를 흉내 낼수 있음.
      - 아래 코드를 보면 literator 가 끝에 도달하는 지 확인해서 처음으로 옮겨 주는 것을 볼수 있음.
      
      ***
   
``` C++
void josephus(int n, int k) {
  //리스트를 준비한다.
  list<int> survivors
  for(int i = 1; i <=n; ++i) survivors.push_back(i);
  // 이번에 죽을 사람을 나타내는 포인터
  list<int>::iterator kill = survivors.begin();
  while(n>2){
    //첫번째 사람이 자살한다. erase()는 지운 원소의 다음 원소를 반환한다.
    kill = survivors.erase(kill);
    if(kill == survivors.end()) kill = survivors.begin();
    --n;
    //k-1번 다음 사람으로 옮긴다.
    for(int i = 0; i < k-1; ++i;) {
      ++kill;
      if(kill == survivors.end()) kill = survivors.begin();
      }
     }
     cout << survivors.front() << " " << survivors.back() << endl;
    }

```
    ***
    
